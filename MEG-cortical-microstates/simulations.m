function simulations()

    % Make ground truth microstate maps
    get_rsns

    % Make ground truth microstate sequences
    generate_MicrostateSequences

    % Perform microstate/PCA/ICA/HMM analysis and analyse
    analyse_clusterSequences

end

function get_rsns()


    % unzip and read the 10 RSNs 
    gunzip('PNAS_Smith09_rsn10.nii.gz') % unzip
    fmri = ft_read_mri('PNAS_Smith09_rsn10.nii') ; % read
    delete('PNAS_Smith09_rsn10.nii') ; % keep only the zipped version for space

    % load in HCP230 atlas
    atlas = load('HCP230.mat') ; 

    % Firstly, we need to align each RSN to the HCP230 atlas

    % Make a fieldtrip grid containing voxels within the brain
    ind = find(any(fmri.anatomy>0,4)) ; % indices of voxels in brain
    [x,y,z] = ind2sub(fmri.dim(1:3),ind) ; % get [x,y,z] coordinates in voxels
    pos = (fmri.transform*[x,y,z,ones(size(x))]')' ; pos = pos(:,1:3) ; % convert to mm
    clear x y z % save memory
    cfg = struct ; cfg.grid.pos = pos ;
    grid = ft_prepare_sourcemodel(cfg) ; % make grid

    % Both HCP230.mat and PNAS_Smith09_rsn10.nii.gz are in normalized MNI
    % space, so we don't need to do any transform. Just interpolate atlas onto
    % grid. 
    cfg = struct ; 
    cfg.parameter = 'tissue' ; 
    cfg.interpmethod = 'nearest' ; 
    interp = ft_sourceinterpolate(cfg,atlas,grid) ; 

    % Remove grid points which have an atlas label of zero, e.g. non-cortical.
    roi = interp ; 
    roi.pos = interp.pos(interp.tissue>0,:) ; 
    roi.tissue = interp.tissue(interp.tissue>0) ; 
    roi.ind = ind(interp.tissue>0) ; 
    clear ind atlas pos grid cfg interp % save some memory

    % loop over RSNs and parcellate according to HCP
    rsn10 = nan(length(roi.tissuelabel),fmri.dim(4)) ; 
    for i = 1:fmri.dim(4)
        vol = fmri.anatomy(:,:,:,i) ; % get the 3d fmri volume for this map
        fun = vol(roi.ind) ; % get the functional values at each grey matter voxel
        for j = 1:length(roi.tissuelabel) ; % loop over rois
            ind = find(roi.tissue == j) ; 
            rsn10(j,i) = mean(fun(ind)) ; 
        end
    end

    % Downsample to 4 RSNs
    % maps 7,1,8,9 - see manuscript text for choice of networks
    classes = [7,1,8,9] ; 
    rsn4 = rsn10(:,classes) ; 

    save('rsnmaps','rsn4','rsn10')
    
end

function generate_MicrostateSequences()

    %%% Script to generate sample microstate sequences
    % This script aims to generate microstate-like sequences. Ideally, we wish
    % to generate sequences with the following properties: 
    % 
    % * Scale-free dynamics, with Hurnst exponent ~0.71 [1]
    % * Mean microstate duration ~50 ms [2,3]
    % * Non-Markovian (order 0-2) [3]
    % 
    % 
    % There are other properties not included here, that could potentially be
    % added:
    % 
    % * Periodic autoinformation at ~20 Hz [3]
    % * Non-stationarity
    % 
    % References:
    % 
    % # Van De Ville et al. (2010) PNAS 107(42)
    % # Tait et al. (2019) bioRxiv 833244
    % # von Wegner et al. (2017) NeuroImage 158

    rsnnum = [4,10] ; % number of rsns to simulate
    numtrials = 20 ; % number of trials to simulate

    for rsnind = 1:length(rsnnum) % loop over different numbers of RSNs

        % Make file to save simulated data to
        sname = sprintf('./generate_microstates/sim_rsn_%d_2',rsnnum(rsnind)) ; 
        if exist([sname '.mat'])
            delete([sname '.mat']) ; 
        end
        sfile = matfile(sname,'Writable',true) ; 

        % Load in the RSN maps generated by sim_get_rsns.m
        load('rsnmaps',sprintf('rsn%d',rsnnum(rsnind))) ; 
        eval(sprintf('W = rsn%d./vecnorm(rsn%d);',rsnnum(rsnind),rsnnum(rsnind))) ;  

        % Loop over trials
        for trial = 1:numtrials
            %% Generate microstate sequences 
            % In [1], the fractal properties of microstates were studied by grouping
            % the 4 microstate maps into 2 sets of pairs, and then assigning each pair
            % a value of +/- 1. Here, we reverse engineer this. Specifically, we
            % generate a random walk and then assign pairs of maps based on the sign of
            % the derivative. Each pair of maps is also given by a random walk, so that
            % we can assign a single map within a pair. This means we need 3 random
            % walks.

            fprintf('Trial %d of %d: ',trial,numtrials)
            tic

            % Initialize an empty microstate object
            ms = microstate.individual ; 

            % Add time axis to microstate object
            fs = 256 ; % sampling rate 256 Hz
            tend = 60 ; % 60 seconds of data
            ms = ms.add_time(fs,tend) ;

            % Simulate a randomwalk to generate microstates
            numstates = rsnnum(rsnind); % number of states to simulate
            ms = ms.simulate_seq_randomwalk('Nstates',numstates) ;

            % Get Markov transitioning
            msm = ms.calculate_syntax ; % Calculate Markov/syntax matrices, save to new object msm

            % Now generate simulated time series

            % Add maps
            ms.maps = eval(sprintf('rsn%d',rsnnum(rsnind))) ;

            % Specify the data is source space - useful for later
            ms.modality = 'source' ; 

            % Simulate and process the time series data - randomwalk
            ms = ms.simulate_data('SNR',1); % simulate
            ms = ms.preprocess_filter(1,30) ; % filter 1-30 Hz

            % Save the output
            if trial == 1
                sfile.Simulation = ms.exportstruct ; 
            else
                sfile.Simulation(trial,1) = ms.exportstruct ; 
            end

            % Clear for memory saving
            clear sim ms

        end

    end

end


function analyse_clusterSequences()

    rsnnum = [4,10] ; % number of rsns to simulate

    for rsnind = 1:length(rsnnum) % loop over different numbers of RSNs

        % Make file to save simulated data to
        sname = sprintf('./generate_microstates/sim_rsn_%d_2',rsnnum(rsnind)) ; 
        sfile = matfile(sname) ; 

        % Make a cohort structure

        % Initialize a cohort
        c = microstate.cohort ; 

        % Loop over trials
        numtrials = length(sfile.Simulation) ; 
        for trial = 1:numtrials

            switch rsnind
                case 1
                    kvec = 4 ;  
                case 2
                    kvec = 10 ; 
            end

            % Load in the microstate object 
            ms = sfile.Simulation(trial,1) ; 
            ms = microstate.individual(ms) ; 

            % Cluster analysis
            ms_sk = ms.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','kmeans') ; 
            ms_sp = ms.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','pca') ; 
            ms_si = ms.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','ica') ; 
            ms_sh = ms.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','hmm') ; 

            % Add to cohort
            c = c.add_individuals(ms,'g') ;
            c = c.add_individuals(ms_sk,'sk') ;
            c = c.add_individuals(ms_sp,'sp') ;
            c = c.add_individuals(ms_si,'si') ;
            c = c.add_individuals(ms_sh,'sh') ;

            % Add to cohort
            GEV(trial,1) = ms_sk.gev ; 
            GEV(trial,2) = ms_sp.gev ; 
            GEV(trial,3) = ms_si.gev ; 
            GEV(trial,4) = ms_sh.gev ; 

            % get MI
            mi = ms_sk.stats_mutualinformation(ms.label) ; MI(trial,1) = mi.stats.mutualinformation ; 
            mi = ms_sp.stats_mutualinformation(ms.label) ; MI(trial,2) = mi.stats.mutualinformation ; 
            mi = ms_si.stats_mutualinformation(ms.label) ; MI(trial,3) = mi.stats.mutualinformation ; 
            mi = ms_sh.stats_mutualinformation(ms.label) ; MI(trial,4) = mi.stats.mutualinformation ; 

            % get MI at peaks
            mi = ms_sk.stats_mutualinformation(ms.label,true) ; MIg(trial,1) = mi.stats.mutualinformation ; 
            mi = ms_sp.stats_mutualinformation(ms.label,true) ; MIg(trial,2) = mi.stats.mutualinformation ; 
            mi = ms_si.stats_mutualinformation(ms.label,true) ; MIg(trial,3) = mi.stats.mutualinformation ; 
            mi = ms_sh.stats_mutualinformation(ms.label,true) ; MIg(trial,4) = mi.stats.mutualinformation ; 

            % map correlation - source
            corrfun = @(x,c) ( (x./vecnorm(x,2,2)) * (c./vecnorm(c,2,2))' )' ;
            x = ms.maps.^2 ;

            m = ms_sk.maps.^2 ; 
            R = corrfun(x',m') ; mapcorr(trial,1) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,1) = mapcorr(trial,1) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            m = ms_sp.maps.^2 ; 
            R = corrfun(x',m') ; mapcorr(trial,2) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,2) = mapcorr(trial,2) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            m = ms_si.maps.^2 ; 
            R = corrfun(x',m') ; mapcorr(trial,3) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,3) = mapcorr(trial,3) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            m = ms_sh.maps.^2 ; 
            R = corrfun(x',m') ; mapcorr(trial,4) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,4) = mapcorr(trial,4) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            % Get observed sequence - ampenv
            msa = ms.preprocess_ampenv ; 
            msa = msa.calculate_gfp ; 

             % find optimum k
            ms_ak = msa.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','kmeans') ; 
            ms_ap = msa.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','pca') ; 
            ms_ai = msa.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','ica') ; 
            ms_ah = msa.cluster_estimatemaps(rsnnum(rsnind),'clustermethod','hmm') ; 

            % Add to cohort
            c = c.add_individuals(ms_ak,'ak') ;
            c = c.add_individuals(ms_ap,'ap') ;
            c = c.add_individuals(ms_ai,'ai') ;
            c = c.add_individuals(ms_ah,'ah') ;

            % Add to cohort
            GEV(trial,5) = ms_ak.gev ; 
            GEV(trial,6) = ms_ap.gev ; 
            GEV(trial,7) = ms_ai.gev ; 
            GEV(trial,8) = ms_ah.gev ; 

            % get MI
            mi = ms_ak.stats_mutualinformation(ms.label) ; MI(trial,5) = mi.stats.mutualinformation ; 
            mi = ms_ap.stats_mutualinformation(ms.label) ; MI(trial,6) = mi.stats.mutualinformation ; 
            mi = ms_ai.stats_mutualinformation(ms.label) ; MI(trial,7) = mi.stats.mutualinformation ; 
            mi = ms_ah.stats_mutualinformation(ms.label) ; MI(trial,8) = mi.stats.mutualinformation ; 

            % get MI at peaks
            mi = ms_ak.stats_mutualinformation(ms.label,true) ; MIg(trial,5) = mi.stats.mutualinformation ; 
            mi = ms_ap.stats_mutualinformation(ms.label,true) ; MIg(trial,6) = mi.stats.mutualinformation ; 
            mi = ms_ai.stats_mutualinformation(ms.label,true) ; MIg(trial,7) = mi.stats.mutualinformation ; 
            mi = ms_ah.stats_mutualinformation(ms.label,true) ; MIg(trial,8) = mi.stats.mutualinformation ; 

            % map correlation - amplitude
            corrfun = @(x,c) ( (x./vecnorm(x,2,2)) * (c./vecnorm(c,2,2))' )' ; 
            x = abs(ms.maps) ;


            m = abs(ms_ak.maps) ; 
            R = corrfun(x',m') ; mapcorr(trial,5) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,5) = mapcorr(trial,5) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            m = abs(ms_ap.maps) ; 
            R = corrfun(x',m') ; mapcorr(trial,6) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,6) = mapcorr(trial,6) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            m = abs(ms_ai.maps) ; 
            R = corrfun(x',m') ; mapcorr(trial,7) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,7) = mapcorr(trial,7) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            m = abs(ms_ah.maps) ; 
            R = corrfun(x',m') ; mapcorr(trial,8) = 0 ; 
            for i = 1:size(m,2)
                mapcorr(trial,8) = mapcorr(trial,8) + max(R(:))/size(m,2) ; 
                [i,j] = find(R == max(R(:))) ; % j->x, i->m
                R(:,j) = [] ; R(i,:) = [] ; 
            end

            cohort = c.stats ; 
            save([sname '_clusterstats'],'GEV','MI','MIg','mapcorr','cohort')
        end

    end

end

